<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: service/scihub/Products.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: service/scihub/Products.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Product from './Product';
import Query from './Query';
import {xml2js} from 'xml-js';

export default class Products {
    /**
     * Products represents collection of the products from different satellites. The Query is focused on the SciHub.
     * @param cache {Map} Cache to be used for storing the retrieved products.
     * @param fetch {Function} Function with provided defaults for making requests.
     * @param baseUrl {String} Optional. Optional URL for the retrieval of the products. Default is SciHub
     */
    constructor(cache, fetch, baseUrl = 'https://scihub.copernicus.eu/apihub/search') {
        this._baseUrl = baseUrl;
        this._cache = cache;

        this._fetch = fetch;
    }

    /**
     * Retrieve the product information from the SciHub. The process has two parts.
     *   The first part is retrieving the products available for given combination of the parameters.
     *   The second part is to retrieve the actual quicklooks for all the products not already stored in cache.
     * @param shortName {String} Short name of the satellite for which to query the data.
     * @param products {String[]} Array of the products to query for.
     * @param location {Object} Latitude, Longitude of specific point.
     * @param beginTime {Date} From when we want the data
     * @param endTime {Date} Until when we want the data
     * @returns {Promise&lt;Product[]>} Product for further use.
     */
    async products({shortName, products = [], location, beginTime, endTime} = {}) {
        const filteredProducts = [];
        const resultsPerPage = 100;
        let startIndex = 0;
        let currentPage;
        do {
            currentPage = await this.load({shortName, products, location, beginTime, endTime, startIndex});
            startIndex += resultsPerPage;

            const processed = this.processProducts(currentPage);
            filteredProducts.push.apply(filteredProducts, processed);
        } while(currentPage.next);

        return filteredProducts;
    }

    /**
     * Retrieve the product information from the SciHub. The process has two parts.
     *   The first part is retrieving the products available for given combination of the parameters.
     *   The second part is to retrieve the actual quicklooks for all the products not already stored in cache.
     * @param shortName {String} Short name of the satellite for which to query the data.
     * @param products {String[]} Array of the products to query for.
     * @param location {Object} Latitude, Longitude of specific point.
     * @param beginTime {Date} From when we want the data
     * @param endTime {Date} Until when we want the data
     * @returns {Promise&lt;Object>}
     *   errors contains array of errors happening during creation of the renderables.
     *   total represents the total amount of products
     *   renderables the renderables tobe displayed
     */
    async renderables({shortName, products = [], location, beginTime, endTime} = {}) {
        const productsLocal = await this.products({shortName, products, location, beginTime, endTime});
        const renderables = [];
        const errors = [];
        for(let productIndex = 0; productIndex &lt; productsLocal.length; productIndex++) {
            try {
                const renderable = await productsLocal[productIndex].renderable();
                if(renderable.error) {
                    errors.push(renderable.error);
                }
                renderables.push(renderable);
            } catch(e) {
                console.log('Products#renderables', e);
                errors.push(e);
            }
        }
        return {
            errors: errors,
            renderables: renderables,
            total: productsLocal.length
        };
    }

    /**
     * From the entries received from Sci Hub creates relevant products with all necessary information for further
     * processing and visualization.
     * @private
     * @param feed {Object} Atom feed with the information about the products.
     * @returns {Array&lt;Product>} Valid products
     */
    processProducts(feed) {
        if(feed.entry &amp;&amp; feed.entry.length > 0) {
            return feed.entry.map(entry => {
                if(entry &amp;&amp; entry.id) {
                    const cached = this._cache.get(entry.id._text);
                    if(!cached) {
                        entry.id = entry.id._text;

                        const str = {};
                        entry.str.forEach(element => {
                            const name = element._attributes.name;
                            str[name] = element._text;
                        });
                        entry.str = str;

                        entry.link = entry.link.map(element => {
                            return {
                                rel: element._attributes.rel,
                                href: element._attributes.href
                            };
                        });

                        const product = new Product(this._fetch, entry);
                        this._cache.set(product.id(), product);
                        return product;
                    } else {
                        return cached;
                    }
                } else {
                    return null;
                }
            }).filter(product => product);
        } else {
            return [];
        }
    }

    /**
     * Load feed with the products from the remote source.
     * @private
     * @param shortName {String} Short name of the satellite for which to query the data.
     * @param products {String[]} Array of the products to query for.
     * @param location {Object} Latitude, Longitude of specific point.
     * @param beginTime {Date} From when we want the data
     * @param endTime {Date} Until when we want the data
     * @param startIndex {Number} The index of the first result to query for.
     * @returns {Promise&lt;Object>} Feed from the response.
     */
    async load({shortName, products = [], location, beginTime, endTime, startIndex} = {}) {
        const query = new Query({shortName, products, location, beginTime, endTime, startIndex});
        const url = this._baseUrl + query.url();

        const cached = this._cache.get(url);
        if(cached) {
            return JSON.parse(cached);
        }

        const response = await this._fetch(url, {
            headers: {
                'Accept': 'application/json'
            }
        });

        const atomFeed = await response.text();
        const root = xml2js(atomFeed, {compact: true});
        const feed = root.feed;
        if(feed.entry &amp;&amp; typeof feed.entry.length === 'undefined') {
            feed.entry = [feed.entry];
        }

        // Here it is necessary to decide whether there are more results.
        const totalResults = Number(feed['opensearch:totalResults']._text);
        const itemsPerPage = Number(feed['opensearch:itemsPerPage']._text);

        feed.next = (startIndex + itemsPerPage) &lt; totalResults;
        this._cache.set(url, JSON.stringify(feed));
        return feed;
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-SunPosition.html">SunPosition</a></li></ul><h3>Classes</h3><ul><li><a href="AcquisitionPlans.html">AcquisitionPlans</a></li><li><a href="AcquisitionPlansCache.html">AcquisitionPlansCache</a></li><li><a href="AcquisitionPlansParser.html">AcquisitionPlansParser</a></li><li><a href="Controls.html">Controls</a></li><li><a href="KmlGroundOverlayFull.html">KmlGroundOverlayFull</a></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="module-CyclicPickController.html">CyclicPickController</a></li><li><a href="module-LayerOrder.html">LayerOrder</a></li><li><a href="module-Model.html">Model</a></li><li><a href="module-Orbits.html">Orbits</a></li><li><a href="module-TexturedSurfacePolygon.html">TexturedSurfacePolygon</a></li><li><a href="StarFieldLayer.html">StarFieldLayer</a></li><li><a href="StarFieldProgram.html">StarFieldProgram</a></li><li><a href="SwathCone.html">SwathCone</a></li><li><a href="TexturedSurfaceShape.html">TexturedSurfaceShape</a></li><li><a href="WebWorker.html">WebWorker</a></li><li><a href="Workers.html">Workers</a></li></ul><h3>Global</h3><ul><li><a href="global.html#footprintAttributes">footprintAttributes</a></li><li><a href="global.html#icon">icon</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#metadata">metadata</a></li><li><a href="global.html#products">products</a></li><li><a href="global.html#renderable">renderable</a></li><li><a href="global.html#renderables">renderables</a></li><li><a href="global.html#topocentricToLookAngles">topocentricToLookAngles</a></li><li><a href="global.html#twoline2satrec">twoline2satrec</a></li><li><a href="global.html#url">url</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Fri Nov 29 2019 13:54:07 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
